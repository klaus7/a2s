package at.ac.meduniwien.mias.adltoschematron.cprimitivehandler;

import static at.ac.meduniwien.mias.adltoschematron.helpers.Utils.*;

import org.apache.commons.lang.StringUtils;
import org.openehr.am.archetype.constraintmodel.primitive.CDate;
import org.openehr.am.archetype.constraintmodel.primitive.CDateTime;
import org.openehr.am.archetype.constraintmodel.primitive.CPrimitive;
import org.openehr.am.archetype.constraintmodel.primitive.CTime;
import org.openehr.am.archetype.constraintmodel.primitive.ICDateTime;
import org.openehr.rm.datatypes.quantity.datetime.DvTemporal;
import org.openehr.rm.support.basic.Interval;

import at.ac.meduniwien.mias.adltoschematron.TreeElement;
import at.ac.meduniwien.mias.adltoschematron.helpers.CdaSpecific;
import at.ac.meduniwien.mias.adltoschematron.helpers.Msg;
import at.ac.meduniwien.mias.adltoschematron.helpers.SetProperties;
import at.ac.meduniwien.mias.adltoschematron.helpers.Utils;

/**
 * The most complex handler. It has to transform from ADL syntax to regular expressions.
 * 
 * @author Klaus Pfeiffer
 */
@CdaSpecific
// because date and time can be represented in a different way in each RM 
// TODO should use dateFormat as configured in the parser.properties
public class CDateTimeHandler extends AbstractCPrimitiveHandler {

	public CDateTimeHandler(final TreeElement te) {
		super(te);
	}

	@Override
	public void generateTests() {
		super.generateTests();

		CPrimitive cp = getTreeElement().getCpo().getItem();
		ICDateTime<?> cd = (ICDateTime<?>) cp;
		Interval<?> interval = cd.getInterval();

		if (interval != null) {
			if (interval.getLower() != null) {

				addPrimitiveConstraintTest(TestGenerator.createIntervalCheckLowerBoundary(this, interval, getRmAttributeName()),
						lang("CLowerBoundary", quote(getRmAttributeName()), wrapValue(interval.getLower())), "a", getRmAttributeName());

			}
			if (interval.getUpper() != null) {

				addPrimitiveConstraintTest(TestGenerator.createIntervalCheckUpperBoundary(this, interval, getRmAttributeName()),
						lang("CUpperBoundary", quote(getRmAttributeName()), wrapValue(interval.getUpper())), "a", getRmAttributeName());

			}
		}

		if (!StringUtils.isEmpty(cd.getPattern())) {

			Msg.add(lang("CDateValueOfDoesntMatchPattern", "@" + getRmAttributeName(), q(cd.getPattern()),
					q(transformToRegex(cd.getPattern()))));
			addPrimitiveConstraintTest("fn:matches(@" + getRmAttributeName() + ", " + q(transformToRegex(cd.getPattern())) + ")",
					Msg.get(), "a", getRmAttributeName());

		} else if (cd.getList() != null) {

			String test = TestGenerator.createListCheck(this, getRmAttributeName(), cd.getList());
			addPrimitiveConstraintTest(test, lang("CList", "@" + getRmAttributeName(), Msg.get()), "a", getRmAttributeName());

		}
	}

	@Override
	public boolean addAssignedValueTest() {

		ICDateTime<?> cd = (ICDateTime<?>) getCP();
		return cd.getList() == null;

	}

	//  **** OpenEHR - ISO 8601 ****
	//	
	//	 ‘?’ (meaning optional)
	//   ‘X’ (not allowed)
	//		
	//	All expressions generated by this grammar must also satisfy the validity rules:
	//		 where ‘??’ appears in a field, only ‘??’ or ‘XX’ can appear in fields to the right
	//		 where ‘XX’ appears in a field, only ‘XX’ can appear in fields to the right
	//	
	//	EBNF; all tokens shown are literals
	//		 date_constraint:
	//		  yyyy - mm|??|XX - dd|??|XX
	//		 time_constraint:
	//		  hh : mm|??|XX : ss|??|XX
	//		 time_in_date_constraint:
	//		  T hh|??|XX : mm|??|XX : ss|??|XX
	//		 date_time_constraint:
	//		  date_constraint time_in_date_constraint
	//	
	//	
	//	**** CDA ****
	//	
	// The value of a point in time is represented using the ISO 8601 compliant form traditionally in use with HL7. This is the form that
	// has no decorating dashes, colons and no "T" between the date and time. In short, the syntax is "YYYYMMDDHHMMSS.UUUU[+|-ZZzz]" where
	// digits can be omitted from the right side to express less precision. Common forms are "YYYYMMDD" and "YYYYMMDDHHMM", but the ability
	// to truncate on the right side is not limited to these two variants. See the Data Types Abstract Specification for detail.

	private String transformToRegex(final String input) {
		String dd = input;

		// replace question marks dependent from position

		boolean month = false;
		boolean day = false;
		boolean minutes = false;
		boolean seconds = false;

		// 2000-01-01T00:00:59+1200
		// hh:??:??
		int qmPos = 0;
		while ((qmPos = dd.indexOf("-??", qmPos + 1)) > -1) {
			// 2000-??-??T10:??:??
			switch (qmPos) {
			case 4: // month
				month = true;
				break;
			case 7: // day
				day = true;
				break;
			}
		}

		qmPos = 0;
		while ((qmPos = dd.indexOf(":??", qmPos + 1)) > -1) {
			switch (qmPos) {
			case 2: // minutes
			case 13:
				minutes = true;
				break;
			case 5:
			case 16: // seconds
				seconds = true;
				break;
			}
		}

		if (month) {
			dd = dd.replaceFirst("-\\?\\?", "(0[1-9]|1[0-2])");
		}
		if (day) {
			dd = dd.replaceFirst("-\\?\\?", "(3[0-2]|0[1-9]|[1-2][0-9])");
		}
		if (minutes) {
			dd = dd.replaceFirst(":\\?\\?", "([0-5][0-9])");
		}
		if (seconds) {
			dd = dd.replaceFirst(":\\?\\?", "([0-5][0-9])");
		}

		dd = Utils.replaceAll(dd,
				//		                      "[:-]\\?\\?", "([0-9][0-9])",
				"[:-]XX", "(00)",
				"hh", "(2[0-3]|[0-1][0-9])",
				":mm", "([0-5][0-9])",
				":ss", "([0-5][0-9])",
				"yyyy", "((19|20)[0-9][0-9])",
				"-mm", "(0[1-9]|1[0-2])",
				"-dd", "(3[0-2]|0[1-9]|[1-2][0-9])",
				"T", "",
				",", "\\.",
				" ", ""
			);

		if (getCP() instanceof CTime) {
			dd = "((19|20)[0-9][0-9])(0[1-9]|1[0-2])(3[0-2]|0[1-9]|[1-2][0-9])" + dd;
		}

		return dd;
	}

	/**
	 * Wrap archetype value
	 */
	@Override
	public String wrapValue(final Object value) {
		DvTemporal<?> dv = (DvTemporal<?>) value;

		String transformedTemporal = Utils.replaceAll(dv.getValue(), ",", ".");

		// add seconds if not available

		int numberOfColons = StringUtils.countMatches(transformedTemporal, ":");

		if (numberOfColons == 1) {
			// add one more
			int li = StringUtils.lastIndexOf(transformedTemporal, ':');

			if (transformedTemporal.length() > li + 3) {
				transformedTemporal = transformedTemporal.substring(0, li + 3) + ":00" + transformedTemporal.substring(li + 3);
			} else if (transformedTemporal.length() == li + 3) {
				transformedTemporal = transformedTemporal.substring(0, li + 3) + ":00";
			}
		}

		// remove precision seconds (can't handle those!) 

		int precPos = transformedTemporal.indexOf('.');
		int pmPos = getTimezoneStartPos(transformedTemporal);

		if (precPos > -1) {

			int uPos = pmPos > -1 ? pmPos : transformedTemporal.length();
			transformedTemporal = reverseSubstring(transformedTemporal, precPos, uPos);

		}

		// place ':' in timezone e.g +0500 becomes +05:00

		pmPos = getTimezoneStartPos(transformedTemporal);
		if (pmPos > -1) {
			if (transformedTemporal.substring(pmPos).length() > 3) {
				transformedTemporal = transformedTemporal.substring(0, pmPos + 3) + ":" + transformedTemporal.substring(pmPos + 3);
			}
		}
		if (pmPos == -1 && !transformedTemporal.contains("Z") && !(getCP() instanceof CDate)) {

			// no timezone specified, add one
			transformedTemporal += SetProperties.defaultTimeZone;
		}

		return q(transformedTemporal);
	}

	private String reverseSubstring(final String input, final int begin, final int end) {
		return input.substring(0, begin) + input.substring(end);
	}

	private int getTimezoneStartPos(final String dd) {
		int pmPos = dd.indexOf('+');
		int dpPos = dd.indexOf(':'); // first ':' is after last '-'
		if (pmPos == -1 && dpPos > -1) {
			// '-' is also in the date
			String sec = dd.substring(dpPos);
			pmPos = sec.indexOf('-');
			if (pmPos > -1) {
				pmPos += dpPos;
			}
		}
		return pmPos;
	}

	/**
	 * Transform CDA date time to xpath compatible date time.
	 * 
	 * @param attr
	 * @return
	 */
	private String transformCdaDateTime(final String attr) {
		String s;
		s = concat(substring(attr, 1, 4), q("-"), substring(attr, 5, 2), q("-"), substring(attr, 7, 2), q("T"), // date
				substring(attr, 9, 2), q(":"), substring(attr, 11, 2), q(":"), substring(attr, 13, 2), // time
				substring(attr, 15, 3), q(":"), substring(attr, 18, 2)); // timezone
		return s;
	}

	private String transformCdaDate(final String attr) {
		String s;
		s = concat(substring(attr, 1, 4), q("-"), substring(attr, 5, 2), q("-"), substring(attr, 7, 2)); // date
		return s;
	}

	private String transformCdaTime(final String attr) {
		String s;
		s = concat(substring(attr, 9, 2), q(":"), substring(attr, 11, 2), q(":"), substring(attr, 13, 2), // time
				substring(attr, 15, 3), q(":"), substring(attr, 18, 2)); // timezone
		return s;
	}

	/**
	 * 
	 * @param input
	 * @param start begins at 1
	 * @param len
	 * @return
	 */
	private String substring(final String input, final int start, final int len) {
		return "fn:substring(" + input + ", " + start + ", " + len + ")";
	}

	private static String q(final String q) {
		return "'" + q + "'";
	}

	private String concat(final String... strings) {
		String s = "fn:concat(";
		for (String string : strings) {
			s += string + ", ";
		}
		s = s.substring(0, s.length() - 2);
		s += ")";
		return s;
	}

	@Override
	public String wrapAttributeFunctionLeft(final String attr) {
		if (getCP() instanceof CDate) {
			return wrapAttributeFunction(transformCdaDate(attr));
		}
		if (getCP() instanceof CTime) {
			return wrapAttributeFunction(transformCdaTime(attr));
		}
		if (getCP() instanceof CDateTime) {
			return wrapAttributeFunction(transformCdaDateTime(attr));
		}
		return attr;
	}

	@Override
	public String wrapAttributeFunction(final String attr) {
		if (getCP() instanceof CDate) {
			return "xs:date(" + attr + ")";
		}
		if (getCP() instanceof CTime) {
			return "xs:time(" + attr + ")";
		}
		if (getCP() instanceof CDateTime) {
			return "xs:dateTime(" + attr + ")";
		}
		return super.wrapAttributeFunction(attr);
	}
}
